// -*-c++-*-
/* This file was automatically generated by rpcc. */

#ifndef __RPCC_CHORD_PROT_H_INCLUDED__
#define __RPCC_CHORD_PROT_H_INCLUDED__ 1

#include "xdrmisc.h"
#include "chord_types.h"


struct chord_findarg {
  chordID x;
  bool return_succs;
};
void *chord_findarg_alloc ();
bool_t xdr_chord_findarg (XDR *, void *);
RPC_STRUCT_DECL (chord_findarg)

template<class T> bool
rpc_traverse (T &t, chord_findarg &obj)
{
  return rpc_traverse (t, obj.x)
    && rpc_traverse (t, obj.return_succs);
}



struct chord_nodearg {
  chord_node_wire n;
};
void *chord_nodearg_alloc ();
bool_t xdr_chord_nodearg (XDR *, void *);
RPC_STRUCT_DECL (chord_nodearg)

template<class T> inline bool
rpc_traverse (T &t, chord_nodearg &obj)
{
  return rpc_traverse (t, obj.n);
}



struct chord_testandfindarg {
  chordID x;
  u_int32_t upcall_prog;
  u_int32_t upcall_proc;
  rpc_bytes<RPC_INFINITY> upcall_args;
  rpc_vec<chordID, RPC_INFINITY> failed_nodes;
};
void *chord_testandfindarg_alloc ();
bool_t xdr_chord_testandfindarg (XDR *, void *);
RPC_STRUCT_DECL (chord_testandfindarg)

template<class T> bool
rpc_traverse (T &t, chord_testandfindarg &obj)
{
  return rpc_traverse (t, obj.x)
    && rpc_traverse (t, obj.upcall_prog)
    && rpc_traverse (t, obj.upcall_proc)
    && rpc_traverse (t, obj.upcall_args)
    && rpc_traverse (t, obj.failed_nodes);
}



struct chord_testandfindres_inrange {
  rpc_vec<chord_node_wire, RPC_INFINITY> n;
};
void *chord_testandfindres_inrange_alloc ();
bool_t xdr_chord_testandfindres_inrange (XDR *, void *);
RPC_STRUCT_DECL (chord_testandfindres_inrange)

template<class T> inline bool
rpc_traverse (T &t, chord_testandfindres_inrange &obj)
{
  return rpc_traverse (t, obj.n);
}



struct chord_testandfindres_notinrange {
  chord_node_wire n;
  rpc_vec<chord_node_wire, RPC_INFINITY> succs;
};
void *chord_testandfindres_notinrange_alloc ();
bool_t xdr_chord_testandfindres_notinrange (XDR *, void *);
RPC_STRUCT_DECL (chord_testandfindres_notinrange)

template<class T> bool
rpc_traverse (T &t, chord_testandfindres_notinrange &obj)
{
  return rpc_traverse (t, obj.n)
    && rpc_traverse (t, obj.succs);
}



struct chord_testandfindres {
  const chordstat status;
  union {
    union_entry_base _base;
    union_entry<chord_testandfindres_inrange> inrange;
    union_entry<chord_testandfindres_notinrange> notinrange;
  };

#define rpcunion_tag_chord_testandfindres status
#define rpcunion_switch_chord_testandfindres(swarg, action, voidaction, defaction) \
  switch (swarg) { \
  case CHORD_INRANGE: \
    action (chord_testandfindres_inrange, inrange); \
    break; \
  case CHORD_NOTINRANGE: \
    action (chord_testandfindres_notinrange, notinrange); \
    break; \
  case CHORD_STOP: \
    voidaction; \
    break; \
  default: \
    voidaction; \
    break; \
  }

  chord_testandfindres (chordstat _tag = (chordstat) 0) : status (_tag)
    { _base.init (); set_status (_tag); }
  chord_testandfindres (const chord_testandfindres &_s)
    : status (_s.status)
    { _base.init (_s._base); }
  ~chord_testandfindres () { _base.destroy (); }
  chord_testandfindres &operator= (const chord_testandfindres &_s) {
    const_cast<chordstat &> (status) = _s.status;
    _base.assign (_s._base);
    return *this;
  }

  void set_status (chordstat _tag) {
    const_cast<chordstat &> (status) = _tag;
    rpcunion_switch_chord_testandfindres
      (_tag, RPCUNION_SET, _base.destroy (), _base.destroy ());
  }
};

template<class T> bool
rpc_traverse (T &t, chord_testandfindres &obj)
{
  chordstat tag = obj.status;
  if (!rpc_traverse (t, tag))
    return false;
  if (tag != obj.status)
    obj.set_status (tag);

  rpcunion_switch_chord_testandfindres
    (obj.status, RPCUNION_TRAVERSE, return true, return false);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
inline bool
rpc_traverse (const stompcast_t &s, chord_testandfindres &obj)
{
  rpcunion_switch_chord_testandfindres
    (obj.status, RPCUNION_REC_STOMPCAST,
     obj._base.destroy (); return true, obj._base.destroy (); return true;);
  /* gcc 4.0.3 makes buggy warnings without the following line */
  return false;
}
void *chord_testandfindres_alloc ();
bool_t xdr_chord_testandfindres (XDR *, void *);
RPC_UNION_DECL (chord_testandfindres)


#ifndef CHORD_PROGRAM
#define CHORD_PROGRAM 344447
#endif /* !CHORD_PROGRAM */
extern const rpc_program chord_program_1;
enum { CHORD_VERSION = 1 };
enum {
  CHORDPROC_NULL = 0,
  CHORDPROC_GETSUCCESSOR = 1,
  CHORDPROC_GETPREDECESSOR = 2,
  CHORDPROC_NOTIFY = 4,
  CHORDPROC_ALERT = 5,
  CHORDPROC_GETSUCCLIST = 6,
  CHORDPROC_TESTRANGE_FINDCLOSESTPRED = 7,
  CHORDPROC_GETPRED_EXT = 10,
  CHORDPROC_GETSUCC_EXT = 12,
  CHORDPROC_GETPREDLIST = 13,
  CHORDPROC_FINDROUTE = 15,
};
#define CHORD_PROGRAM_1_APPLY_NOVOID(macro, void) \
  macro (CHORDPROC_NULL, chordID, void) \
  macro (CHORDPROC_GETSUCCESSOR, chordID, chord_noderes) \
  macro (CHORDPROC_GETPREDECESSOR, chordID, chord_noderes) \
  macro (3, false, false) \
  macro (CHORDPROC_NOTIFY, chord_nodearg, chordstat) \
  macro (CHORDPROC_ALERT, chord_nodearg, chordstat) \
  macro (CHORDPROC_GETSUCCLIST, chordID, chord_nodelistres) \
  macro (CHORDPROC_TESTRANGE_FINDCLOSESTPRED, chord_testandfindarg, chord_testandfindres) \
  macro (8, false, false) \
  macro (9, false, false) \
  macro (CHORDPROC_GETPRED_EXT, chordID, chord_nodelistextres) \
  macro (11, false, false) \
  macro (CHORDPROC_GETSUCC_EXT, chordID, chord_nodelistextres) \
  macro (CHORDPROC_GETPREDLIST, chordID, chord_nodelistres) \
  macro (14, false, false) \
  macro (CHORDPROC_FINDROUTE, chord_findarg, chord_nodelistres)
#define CHORD_PROGRAM_1_APPLY(macro) \
  CHORD_PROGRAM_1_APPLY_NOVOID(macro, void)

#endif /* !__RPCC_CHORD_PROT_H_INCLUDED__ */
