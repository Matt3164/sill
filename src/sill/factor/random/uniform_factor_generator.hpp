#ifndef SILL_UNIFORM_FACTOR_GENERATOR_HPP
#define SILL_UNIFORM_FACTOR_GENERATOR_HPP

#include <sill/factor/table_factor.hpp>

#include <boost/random/uniform_real.hpp>

#include <sill/macros_def.hpp>

namespace sill {

  /**
   * Functor for generating table factors that are filled uniformly
   * (in the log space).
   *
   * Marginal factors are generated by assigning to each element i
   * a random value exp(x_i) for x_i drawn from Uniform[lower, upper].
   * Conditional factors are generated by first generating a marginal
   * factor and then computing the conditional using standard factor
   * operations.
   *
   * \see RandomFactorGenerator
   * \ingroup factor_random
   */
  class uniform_factor_generator {
  public:
    // RandomFactorGenerator typedefs
    typedef finite_domain domain_type;
    typedef table_factor  result_type;

    struct param_type {
      double lower;
      double upper;

      param_type()
        : lower(-1.0), upper(1.0) { }

      param_type(double lower, double upper)
        : lower(lower), upper(upper) {
        check();
      }

      void check() const {
        assert(lower <= upper);
      }

      friend std::ostream& operator<<(std::ostream& out, const param_type& p) {
        out << p.lower << " " << p.upper;
        return out;
      }
    }; // struct param_type

    //! Constructs a generator of factors filled uniformly within limits
    explicit uniform_factor_generator(double lower = -1.0, double upper = 1.0)
      : params(lower, upper) { }

    //! Constructs generator with the given parameters
    explicit uniform_factor_generator(const param_type& params)
      : params(params) { params.check(); }

    //! Generate a marginal distribution p(args) using the stored parameters.
    template <typename RandomNumberGenerator>
    table_factor operator()(const finite_domain& args,
                            RandomNumberGenerator& rng) {
      boost::uniform_real<> unif(params.lower, params.upper);
      table_factor f(args);
      foreach(double& value, f.values()) {
        value = std::exp(unif(rng));
      }
      return f;
    }

    //! Generates a conditional distribution p(head | tail) using the stored
    //! parameters. Implemented by conditiong a random marginal distribution.
    template <typename RandomNumberGenerator>
    table_factor operator()(const finite_domain& head,
                            const finite_domain& tail,
                            RandomNumberGenerator& rng) {
      return operator()(set_union(head, tail), rng).conditional(tail);
    }

    //! Returns the parameter set associated with this generator
    const param_type& param() const {
      return params;
    }

    //! Sets the parameter set associated with this generator
    void param(const param_type& params) {
      params.check();
      this->params = params;
    }

  private:
    param_type params;

  }; // class uniform_factor_generator

  //! Prints the parameters of the generator to an output stream.
  //! \relates uniform_factor_generator
  inline std::ostream&
  operator<<(std::ostream& out, const uniform_factor_generator& gen) {
    out << gen.param();
    return out;
  }

} // namespace sill

#include <sill/macros_undef.hpp>

#endif
